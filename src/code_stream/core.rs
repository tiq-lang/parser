//! This module contains core parts of the code stream ecosystem: `CodeStream` and `CodeSpan` traits
//! and span-related data structures.

use crate::origin;
use std::num::NonZero;

/// Contains information about the code span origin.
///
/// The purpose of the span system is to provide a way to point to segments of the source code.
/// This explains some of the design decisions that were made. Firstly, for natural spans we want
/// to be able to calculate the position of bytes within the source file. To do so we additionally
/// store `position_in_file` for natural spans. Secondly, transitive invocation of codegen tools
/// shouldn't point to the synthetic code, because that is not useful. That explains why only
/// natural macros, attributes and etc. can act as span origins.
#[derive(Clone, Copy, Debug, PartialEq)]
pub enum SpanOrigin {
    File {
        file: &'static origin::File,
        position_in_file: usize,
    },
    Macro {
        r#macro: &'static origin::Macro,
    },
    Derive {
        derive: &'static origin::Derive,
    },
    Attribute {
        attribute: &'static origin::Attribute,
    },
}

/// Represents semi-unique identifier of a span. `SpanId`s that are obtained from a single stream
/// can be compared to check if two bytes come from a single span.
///
/// ## Invariants
/// * `SpanId`s of two bytes, that come from a single stream, compare equal if and only if
/// these bytes and all bytes between them come from a single span.
#[derive(Clone, Copy, PartialEq)]
pub struct SpanId(pub(super) NonZero<usize>);

/// Main interface of interaction with the span system.
///
/// Span system is designed to provide a way to point to segments of the source code. Spans are
/// divided into two main categories: natural and synthetic. Natural spans are those, whoose
/// contents come directly from some file. Synthetic spans are ones, which are generated by the
/// compiler codegen tools (macros, attributes, etc.).
///
/// Category of the span can be determined by looking at its origin. Natural spans have
/// `SpanOrigin::File` as their origin, while synthetic spans have `SpanOrigin::Macro`,
/// `SpanOrigin::Derive` or `SpanOrigin::Attribute` as theirs.
///
/// `SpanId`s serve as a way of telling whether given segment of the code comes from a single span
/// or if it crosses the span boundaries.
pub trait CodeSpan {
    /// Obtains semi-unique identifier of a span.
    ///
    /// Read `SpanId` documentation for more information.
    fn get_id(&self) -> SpanId;

    /// Obtains information about span origin.
    ///
    /// Read `SpanOrigin` documentation for more information.
    fn get_origin(&self) -> &SpanOrigin;
}

/// Result of calling the `CodeStream::get_span_info` method. Contains information about the span
/// of queried byte and offset of the byte within that span.
///
/// Read more information regarding code spans in the documentation of the `CodeSpan` trait.
#[derive(Clone, Copy, Debug)]
pub struct GetSpanInfoResult<'a, S: CodeSpan + ?Sized> {
    pub span: &'a S,
    pub offset_in_span: usize,
}

/// Base interface of interaction with code streams. Abstracts away tools for inspecting and
/// advancing streams, locating and extracting stream data.
pub trait CodeStream {
    /// Type with all possible errors, that may occur in any of the stream operations.
    /// Parsing functions simply propagate these errors and do not handle them.
    type Error;

    /// Type of the span for a given stream.
    ///
    /// Read `CodeSpan` documentation for more information.
    type Span: CodeSpan;

    /// Consume `amount` bytes from the stream, changing the pointed-to byte.
    ///
    /// ## Safety
    /// `self.peek_offset(amount - 1)` must be `Some`. In particular, this function causes UB if
    /// `self.peek()` is `None`, no matter the `amount` (stream can't be advanced past the end).
    unsafe fn advance_by(&mut self, amount: NonZero<usize>) -> Result<(), Self::Error>;

    /// Look up the `offset`th after the pointed-to byte without advancing the stream.
    /// Returns `None` if the `offset`th byte is exactly after the last byte of a stream.
    ///
    /// ## Safety
    /// Stream must have greater then or exactly `offset` bytes left (including the pointed-to
    /// byte). Note that this implies, that `self.peek_offset(0)` is always safe.
    unsafe fn peek_offset(&self, offset: usize) -> Result<Option<u8>, Self::Error>;

    /// Equivalent to `self.peek_offset(0)`. See the documentation there.
    fn peek(&self) -> Result<Option<u8>, Self::Error> {
        // Safe because `self.peek_offset(0)` is always safe
        unsafe { self.peek_offset(0) }
    }

    /// Try to get contiguous slice of `length` bytes with given `offset` from the pointed-to byte
    /// without advancing the stream. Returns the slice of maximal length that is less than or equal
    /// to `length`. Returned slice is empty if and only if the stream is exhausted.
    ///
    /// ## Safety
    /// This function is safe whenever `self.peek_offset(offset)` is safe. For proper definition of
    /// safety see the documentation for `peek_offset`. Note that this implies that
    /// `self.get_slice_offset(0, length)` is always safe.
    unsafe fn get_slice_offset(
        &self,
        offset: usize,
        length: NonZero<usize>,
    ) -> Result<&[u8], Self::Error>;

    /// Equivalent to `self.get_slice_offset(0, length)`. See the documentation there.
    fn get_slice(&self, length: NonZero<usize>) -> Result<&[u8], Self::Error> {
        // Safe because `self.peek_offset(0)` is always safe
        unsafe { self.get_slice_offset(0, length) }
    }

    /// Provides information about the span of the byte located after `offset` bytes from currently
    /// viewed byte. If this function is called when `self.peek_offset(offset)` is `None`, returns
    /// span information as if this 'byte' was located inside of the last span.
    ///
    /// ## Safety
    /// This function is safe when `self.peek_offset(offset)` is safe. Note that this implies
    /// that `self.get_span_info_offset(0)` is always safe.
    unsafe fn get_span_info_offset(
        &self,
        offset: usize,
    ) -> Result<GetSpanInfoResult<Self::Span>, Self::Error>;

    /// Same as `self.get_span_info_offset(0)`. See the documentation there.
    fn get_span_info(&self) -> Result<GetSpanInfoResult<Self::Span>, Self::Error> {
        // Safe because `self.peek_offset(0)` is always safe
        unsafe { self.get_span_info_offset(0) }
    }
}
